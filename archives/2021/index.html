<!DOCTYPE html>

<html lang="en">

<head>
  
  <title>Archive：2021 - 小曾的博客</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <meta property="og:type" content="website">
<meta property="og:title" content="小曾的博客">
<meta property="og:url" content="http://example.com/archives/2021/index.html">
<meta property="og:site_name" content="小曾的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zengyj">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
  <link rel="stylesheet" href="/css/style.css?v=1627804220879">
  
  <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1627804220879">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/nexmoe/nexmoe.github.io@latest/images/cover/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="zengyj" class="mdui-btn mdui-btn-icon"><img src="https://www.hualigs.cn/image/60fc3cd247b8f.jpg" alt="zengyj"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="zengyj">
            <img src="https://www.hualigs.cn/image/60fc3cd247b8f.jpg" alt="zengyj" alt="zengyj">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>5</div>
        <div><span>Tags</span>2</div>
        <div><span>Categories</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="Search"></label>
            </form>
         
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/JS/" style="font-size: 20px;">JS</a>
    </div>
    
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 zengyj
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2021/05/20/ES6%E7%B1%BB/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2018/01/23/10/38/book-3101151__340.jpg" data-sizes="auto" alt="讲一讲ES6中的类" class="lazyload">
                    <h1>讲一讲ES6中的类</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月20日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <span id="more"></span>

<h1 id="讲一讲ES6中的类"><a href="#讲一讲ES6中的类" class="headerlink" title="讲一讲ES6中的类"></a>讲一讲ES6中的类</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中定义了一个类，constructor代表构造函数，上述还定义了一个toString()方法，前面不需要加上function这个关键字，另外，方法与方法之间不需要逗号分隔，加了会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = new Point();</span><br></pre></td></tr></table></figure>

<p>使用时与构造函数用法无异。</p>
<p>另，注意，类中的方法都是不可枚举的，例如下面代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>而如果采用ES5写法，则是可枚举的</p>
<p>constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<p>我们也可在类中对某个属性设置存值函数和取值函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另，如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<p>补充知识：</p>
<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>; <span class="comment">//表示异步需要暂停的地方</span></span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>顾名思义，在方法前加static，表示该方法不会被实例对象所继承，直接通过类调用。静态方法可以与非静态方法重名。父类的静态方法，可以被子类继承。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>类的实例属性有两种定义方式，如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>类的静态属性方法有两种定义方式，如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="私有方法与私有属性"><a href="#私有方法与私有属性" class="headerlink" title="私有方法与私有属性"></a>私有方法与私有属性</h2><p>类的私有方法方法有两种定义方式，如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：加入下划线形式class Widget &#123;  _bar(baz) &#123;    return this.snaf = baz;  &#125;&#125;//方法二：将私有方法移出类class Widget &#123;  foo (baz) &#123;    bar.call(this, baz);  &#125;&#125;function bar(baz) &#123;  return this.snaf = baz;&#125;</span></span><br></pre></td></tr></table></figure>

<p>私有属性的定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;  #count = <span class="number">0</span>;  <span class="comment">//也可用来定义私有方法  #sum() &#123;    return this.#a + this.#b;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  <span class="function"><span class="title">use</span>(<span class="params">obj</span>)</span> &#123;    <span class="keyword">if</span> (#foo <span class="keyword">in</span> obj) &#123;      <span class="comment">// 私有属性 #foo 存在    &#125; else &#123;      // 私有属性 #foo 不存在    &#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h2><p>属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;    <span class="built_in">this</span>.name = name;  &#125; <span class="keyword">else</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);  &#125;&#125;<span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确var notAPerson = Person.call(person, &#x27;张三&#x27;);  // 报错</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类通过”extends“来继承，如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意，子类的构造函数必须先调用父类的构造函数才能再进行自我加工。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;    <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)    this.color = color;  &#125;  toString() &#123;    return this.color + &#x27; &#x27; + super.toString(); // 调用父类的toString()  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，父类的静态方法也会被子类所继承。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super一方面充当父类的构造函数，另一方面当对象使用，<strong>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p>
<p>注意：如果在子类中使用super对某个属性进行赋值，此时super会化身this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;    <span class="built_in">this</span>.x = <span class="number">1</span>;  &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;    <span class="built_in">super</span>();    <span class="built_in">this</span>.x = <span class="number">2</span>;    <span class="built_in">super</span>.x = <span class="number">3</span>;    <span class="built_in">console</span>.log(<span class="built_in">super</span>.x); <span class="comment">// undefined    console.log(this.x); // 3  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="老生常谈的prototype和-proto"><a href="#老生常谈的prototype和-proto" class="headerlink" title="老生常谈的prototype和__proto__"></a>老生常谈的prototype和__proto__</h2><p>在class中，它同时拥有prototype属性和_proto_属性，其中</p>
<p>子类的__proto__属性，表示构造函数的继承，总是指向父类</p>
<p>子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</p>
<p>正是因为上述规则，类的继承是按如下代码实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;<span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;<span class="comment">// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();</span></span><br></pre></td></tr></table></figure>


            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/10/Reflect/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2020/12/16/18/25/zebras-5837321__340.jpg" data-sizes="auto" alt="Reflect" class="lazyload">
                    <h1>Reflect</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月10日</a>
            <a><i class="nexmoefont icon-areachart"></i>97 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <p>Reflect是ES6提出的新对象，下面来展开Reflect。</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/05/03/proxy/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/07/20/11/50/poppies-6480490__340.jpg" data-sizes="auto" alt="令人忽视的Proxy" class="lazyload">
                    <h1>令人忽视的Proxy</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年05月03日</a>
            <a><i class="nexmoefont icon-areachart"></i>200 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <span id="more"></span>

<h1 id="令人忽视的Proxy"><a href="#令人忽视的Proxy" class="headerlink" title="令人忽视的Proxy"></a>令人忽视的Proxy</h1><p>Proxy在ES6中首次被提出，却经常性被忽略。今天来讲讲其中被人忽视的“细节“。</p>
<p>Proxy看似难以理解，实际上就是充当”拦截器“的用处，用Proxy来代理操作。</p>
<p>下面代码定义了一个Proxy实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>其中，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。例如下面代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>从上述我们能看到，之后我们得通过proxy实例对象进行操作，而不是通过目标对象。</p>
<p>下面是列举支持的拦截操作函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(target, propKey, receiver)</span><br><span class="line">set(target, propKey, value, receiver)</span><br><span class="line">has(target, propKey)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>




            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/29/2/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2020/11/07/10/24/desert-5720527_960_720.jpg" data-sizes="auto" alt="谈谈HTML涉及到的面试题" class="lazyload">
                    <h1>谈谈HTML涉及到的面试题</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月29日</a>
            <a><i class="nexmoefont icon-areachart"></i>498 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <p>在众多互联网公司的面试题目中，看似HTML所涉及到的内容寥寥可数，但却是面试者不容忽视的，以下我将把出现频率较多的HTML面试题进行汇总：</p>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/04/25/my-first-blog/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/06/19/17/51/italy-6349105_960_720.jpg" data-sizes="auto" alt="细数HTML5新特性" class="lazyload">
                    <h1>细数HTML5新特性</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年04月25日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.3k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 5 分钟</a>
        </div>

        <article>
            
                <p>HTML5作为HTML最新的版本，已是于2014年完成标准指定。其最初的设计目的本来是为运行在移动设备上，而今在前端面试题中也层出不穷，下面将把HTML5揉碎，一点一点细数它的新特性。</p>
            
        </article>
    </div>
    
</section>

        <div class="nexmoe-post-right">
          <div class="nexmoe-fixed">
            <div class="nexmoe-tool"> 
              
                
              
              <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
            </div>
          </div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1627804220880"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


  





</body>

</html>
